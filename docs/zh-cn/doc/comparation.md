主流Mock工具对比
---

除`TestableMock`外，目前主要的Mock工具主要有`Mockito`、`Spock`、`PowerMock`和`JMockit`，基本差异如下：

|  工具         | 原理           | 最小Mock单元  | 对被Mock方法的限制          | 上手难度   | IDE支持  |
|  ----        | ----          | ----         | ----                     | ----      | ----    |
| Mockito      | 动态代理        | 类           | 不能Mock私有/静态和构造方法  | **较容易** | **很好** |
| Spock        | 动态代理        | 类           | 不能Mock私有/静态和构造方法  | 较复杂     | 一般     |
| PowerMock    | 自定义类加载器   | 类           | **任何方法皆可**           | 较复杂     | **较好** |
| JMockit      | 运行时字节码修改 | 类            | 不能Mock构造方法(new操作符) | 较复杂     | 一般     |
| TestableMock | 运行时字节码修改 | 方法          | **任何方法皆可**           | **较容易** | **较好** |

`Mockito`是Java最老牌的Mock工具，稳定性和易用性较好，IntelliJ和Eclipse都有专用插件支持。相对不足之处在于Mock功能稍弱，在必要情况下需与其他Mock工具配合使用。

`Spock`是一款代码可读性非常高的单元测试框架，内置Mock支持，具有很好的整体感。由于同样基于动态代理实现，其不足点与`Mockito`类似。

`PowerMock`是一款功能十分强大的Mock工具，其基本语法与`Mockito`兼容，同时扩展了许多`Mockito`缺失的功能，包括对支持对私有、静态和构造方法实施Mock。但由于使用了自定义类加载器，会导致Jacoco在默认的`on-the-fly`模式下覆盖率跌零。

`JMockit`是一款功能性与易用性均居于`Mockito`与`PowerMock`之间的Mock工具，较好的弥补了两者各自的不足。该项目在2017年尝试推出JMockit2重写版本但未能完成，目前处于不活跃的维护状态。

相比之下，`TestabledMock`的功能与`PowerMock`基本平齐，且极易上手，只需掌握一个`@MockInvoke`注解就可以完成绝大多数Mock操作。

## TestableMock的不足

为了便于开发者进行Mock工具的合理选型，我们认为客观的强调`TestabledMock`存在的不足，与阐述它的优点同样重要。

任何事物都有两面性。由于`TestableMock`独辟蹊径采用“每个业务类拥有一个专属Mock容器类”的思维方式，将Mock方法定义与单元测试用例解耦，一方面使得Mock方法具有默认可复用性，单元测试用例也因此变得更干净纯粹，另一方面也导致Mock方法定义变得零散，生命周期管理起来相对困难，对现有开发者的Mock编写习惯会带来一定改变。

此外，`TestableMock`最初的设计主要面向标准单元测试场景（每个类有自己的测试用例，测试类与被测类基本逐一对应）。为了最大限度的提升易用性，把需要用到的注解、操作步骤都减少到最少，`TestableMock`采用了许多“约定优于配置”的设计。譬如被测量、测试类与Mock容器类在同一包路径，且分别按约定命名等。对于单元测试较规范的项目而言，`TestableMock`将极大降低Mock引入的成本；对于规范不足的项目，依然可以结合`@MockWith`、包路径映射等功能完成相同的Mock效果，但应当尤其注意这些“花哨”的功能对代码可读性和可维护性带来的负面影响。
